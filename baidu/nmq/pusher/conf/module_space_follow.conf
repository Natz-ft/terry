[modules]
#下面是一个模块的配置

[.@module]
#模块名,需要跟ubclient配置里面的名称一致;
name : space_follow
#是否启用 1启用 0停用
flag : 1
#是竞争模式还是多主模式;0:竞争,1:多主
sending_type : 1
#转发协议配置;
sending_protocol : mcpack
#发送窗口大小,需要比线程数大;
sending_window_size : 2
#发送线程数。竞争模式为竞争线程数，多主模式下，为每个机器的并发线程数
sending_thread_num : 1
#出错后重试的时间间隔（单位MS)
sending_retry_time: 300
#填充窗口的吞吐率； 是指 每次尝试填充多少比例的空白窗口。 [默认为2，可以根据情况处理。]
#越大则填充效率越高，但单次处理耗时略增加，适用于并发度很高的产品，可以尽可能提高吞吐并发度。
#越小则填充效率较低，但单次处理较快，适用于并发度不高的产品，可以提高响应速度。
sending_fill_window_count: 3
#延迟发送时间（单位MS)
sending_delay_time : 0
#当topic没有新的di数据时，talk线程sleep的时间间隔，默认为1(单位MS)
sleeping_time_while_no_di : 1
#模块启动的时候，如果status里的transid太小，在topic数据里找不到时，是否自动跳到当前可读的最小transid，默认0
auto_skip_transid : 0

#命令过滤规则 ，接受的命令配置；
# *表示通配，只能出现在字符串的最后，不能出现在中间
[..msg_filter]
@filter : space.follow.*

#时序控制规则，支持按照某个partition key的时序支持
[..sequence_control]
#制定mutex key，必须是整形数类型的字段；
mutex_key : srcid

#指定对于 没有PK的命令，是否强制串行处理；
#1：是：该命令必须等待所有靠前的命令都执行完成，再执行。该命令执行前，靠后的命令也不能执行。（主要用于存在批量命令时，保证时序）。
#0：否：该命令完全无序，到了就执行。
force_sequence_when_no_mutex_key : 0

[..req_check]
#如果mcpack里找不到req_check定义的字段，是否通过(给下游发出去)
pass_when_no_req_segment : 1
#自定义的check表达式，支持 (, ), +, -, *, /, ||, &&
req_check : 

#支持任意模块自定义配置、so自定义配置
[..ext_config]
custom_key : sample

#mcpack字段复制
#在消息中间件中，内部填充字段都是以"_"开头，比如_transid, _log_id等，为了兼容，可以在so中将这些字段复制改名;
#[...@mcpack_key_copy]
#from : _log_id
#to : log_id


